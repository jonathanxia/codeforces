#include <errno.h>
#include <fcntl.h>
#include <lib/common.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <unistd.h>

// Processes return statuses; if the status is error, will exit with the
// corresponding errno of the syscall. Prints err_msg to perror if there is
// an error.
int check_status(int ret_status, char* err_msg)
{
    if (ret_status < 0) {
        // perror might fail, so we need to return the original errno,
        // not the one generated by perror
        int orig_errno = errno;
        perror(err_msg);
        exit(orig_errno);
    }
    return ret_status;
}

void run_command(char* command_name)
{
    check_status(execlp(command_name, command_name, NULL), command_name);
}

int main(int argc, char* argv[])
{
    if (argc <= 1) { // If no commands to run, exit with EINVAL
        errno = EINVAL;
        exit(errno);
    }
    int client_fd[2];
    int server_fd[2];
    eprint("Creating client pipe");
    pipe(client_fd);
    eprint("Creating server pipe");
    pipe(server_fd);

    eprint("Forking server");
    int pid_server = fork();
    if (pid_server == 0) {
        // server
        dup2(client_fd[0], STDIN_FILENO);
        dup2(server_fd[1], STDOUT_FILENO);
        run_command(argv[1]);
    } else {
        eprint("Forking client");
        int pid_client = fork();
        if (pid_client == 0) {
            // client
            dup2(server_fd[0], STDIN_FILENO);
            dup2(client_fd[1], STDOUT_FILENO);
            run_command(argv[2]);
        } else {
            int st;
            waitpid(pid_server, &st, 0);
            waitpid(pid_client, &st, 0);
        }
    }
    return 0;
}